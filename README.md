#  Лабораторна робота: Поведінкові UML-діаграми

**Дисципліна:** Проєктування інформаційних систем  
**Тема:** Побудова поведінкових UML-діаграм для проєктування ІС  
**Інструмент моделювання:** Mermaid.js  
**Предметна область:** Система автоматизованого налаштування мережевого обладнання

---

##  Мета роботи

Набути практичних навичок моделювання інформаційної системи за допомогою поведінкових UML-діаграм: навчитися аналізувати вимоги до системи та візуалізувати її структуру й поведінку.

---

##  Предметна область

Система автоматизованого налаштування мережевого обладнання дозволяє мережевим інженерам централізовано керувати конфігурацією маршрутизаторів і комутаторів через Ansible Playbook-и та Python API. Замість ручного підключення до кожного пристрою окремо — інженер запускає один сценарій, який автоматично підключається до всіх пристроїв через SSH і застосовує необхідні налаштування.

**Актори системи:**

| Актор | Роль |
|---|---|
|  Мережевий інженер | Запускає playbook-и, переглядає звіти, відкочує конфігурацію |
|  Адміністратор | Керує інвентарем пристроїв та користувачами системи |
|  Мережевий пристрій | Об'єкт налаштування (Cisco, MikroTik тощо) |

---

##  Діаграми

### 1. Use Case Diagram — Діаграма варіантів використання

```mermaid
graph LR
    Engineer([" Мережевий інженер"])
    Admin([" Адміністратор"])
    Device([" Мережевий пристрій"])

    subgraph sys [" Система автоматизованого налаштування "]
        subgraph auth [" Доступ"]
            UC1(["Увійти до системи"])
        end

        subgraph manage [" Управління інвентарем"]
            UC2(["Переглянути інвентар"])
            UC3(["Додати / видалити пристрій"])
        end

        subgraph run [" Виконання"]
            UC4(["Запустити Playbook"])
            UC5(["Переглянути статус задачі"])
            UC6(["Переглянути звіт"])
        end

        subgraph recovery [" Відновлення"]
            UC7(["Відкатити конфігурацію"])
        end
    end

    Engineer --- UC1
    Engineer --- UC2
    Engineer --- UC4
    Engineer --- UC5
    Engineer --- UC6
    Engineer --- UC7

    Admin --- UC1
    Admin --- UC2
    Admin --- UC3

    UC4 -. "SSH-підключення" .-> Device
    UC7 -. "відновлює" .-> Device
```

---

### 2. Sequence Diagram — Діаграма послідовності

```mermaid
sequenceDiagram
    actor Engineer as  Інженер
    participant UI as  Інтерфейс
    participant API as  API Server
    participant Ansible as  Ansible Engine
    participant Device as  Пристрій

    Engineer->>UI: Обрати пристрої та playbook
    UI->>API: POST /run-playbook

    API->>API: Валідація YAML синтаксису

    alt  Валідація провалилась
        API-->>UI: 400 Bad Request — помилка синтаксису
        UI-->>Engineer: Показати помилку для виправлення
    else  Валідація успішна
        API-->>UI: Задача прийнята, виконується
        UI-->>Engineer: Задача поставлена в чергу

        API->>Ansible: Запустити playbook з інвентарем

        loop Для кожного пристрою
            Ansible->>Device: SSH — надіслати команди конфігурації
            Device-->>Ansible: Виконано  або Помилка 
        end

        Ansible-->>API: Підсумковий звіт виконання
        API-->>UI: Задача завершена
        UI-->>Engineer: Показати детальний звіт
    end
```

---

### 3. Activity Diagram — Діаграма діяльності

```mermaid
flowchart TD
    Start(["▶ Початок"])

    A[" Авторизація в системі"]
    B{Доступ дозволено?}

    C[" Вибір пристроїв з інвентарю"]
    D[" Вибір Ansible Playbook"]
    E[" Валідація YAML синтаксису"]
    F{Playbook коректний?}
    G[" Виправити помилки у playbook"]

    H[" Запуск Ansible Playbook"]

    subgraph exec [" Виконання на пристроях"]
        H1["SSH-підключення до пристрою"]
        H2["Надсилання команд конфігурації"]
        H3["Отримання результату"]
        H1 --> H2 --> H3
    end

    I{Всі пристрої налаштовано?}
    J[" Зберегти конфігурацію та сформувати звіт"]
    K{Є критичні помилки?}
    L[" Відкатити до попередньої конфігурації"]
    M([" Завершено успішно"])
    N([" Завершено з помилками"])

    Start --> A --> B
    B -- Відмовлено --> A
    B -- Дозволено --> C --> D --> E --> F
    F -- Ні --> G --> E
    F -- Так --> H --> exec --> I
    I -- Ні --> H1
    I -- Так --> J --> K
    K -- Ні --> M
    K -- Так --> L --> N

    style Start fill:#16a34a,color:#fff,stroke:none
    style M fill:#dcfce7,stroke:#16a34a,color:#15803d
    style N fill:#fee2e2,stroke:#dc2626,color:#dc2626
    style B fill:#fef08a,stroke:#ca8a04
    style F fill:#fef08a,stroke:#ca8a04
    style I fill:#fef08a,stroke:#ca8a04
    style K fill:#fef08a,stroke:#ca8a04
    style G fill:#fff7ed,stroke:#ea580c
    style L fill:#fff7ed,stroke:#ea580c
    style exec fill:#eff6ff,stroke:#3b82f6,stroke-dasharray:4
```

---

##  Зв'язок між діаграмами

| Діаграма | Відповідає на питання | Ключовий сценарій |
|---|---|---|
| **Use Case** | Хто? Що робить? | Актори та всі функції системи |
| **Sequence** | Як об'єкти взаємодіють? | Деталі запуску Playbook (UC4) |
| **Activity** | Який алгоритм кроків? | Повний процес від входу до звіту |

Усі три діаграми описують **один і той самий процес** — автоматизоване налаштування мережевого обладнання — але з різних точок зору: від загального (хто що робить) до конкретного (як саме і в якому порядку).

---

##  Висновок

У ході виконання лабораторної роботи обрано предметну область — систему автоматизованого налаштування мережевого обладнання на базі Ansible та Python. Побудовано три взаємопов'язані UML-діаграми: Use Case відображає функції системи та акторів, Sequence деталізує взаємодію компонентів при запуску playbook, Activity описує повний алгоритм процесу з розгалуженнями та обробкою помилок. Усі діаграми виконано у Mermaid.js та оформлено в Markdown.
